<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>âš¡ï¸ å¯¶å¯å¤¢å¤§äº‚é¬¥ (ä¿®å¾©ç‰ˆ) âš¡ï¸</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <style>
        /* (CSS ä¿æŒä¸è®Šï¼Œç•¥éä»¥ç¯€çœç©ºé–“ï¼Œè«‹ç›´æ¥ä½¿ç”¨ä¸Šä¸€ç‰ˆçš„ CSS) */
        body { font-family: 'Segoe UI', sans-serif; background-color: #1a1a2e; color: #fff; padding: 20px; user-select: none; }
        .container { max-width: 900px; margin: 0 auto; }
        .navbar { display: flex; justify-content: space-between; align-items: center; background: #16213e; padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #0f3460; }
        .user-info { display: flex; gap: 15px; width: 100%; }
        .user-avatar { width: 65px; height: 65px; border-radius: 50%; border: 3px solid #f1c40f; object-fit: cover; }
        .user-stats { flex: 1; }
        .bar-container { width: 100%; background: #333; height: 10px; border-radius: 5px; margin-top: 4px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: linear-gradient(90deg, #e74c3c, #c0392b); }
        .xp-fill { background: linear-gradient(90deg, #f1c40f, #f39c12); }
        .pet-xp-fill { background: linear-gradient(90deg, #3498db, #2980b9); }
        .bar-text { font-size: 0.8em; color: #ccc; display: flex; justify-content: space-between; }
        .atk-val { color: #f1c40f; font-weight: bold; }
        .btn-logout { background: transparent; border: 1px solid #e74c3c; color: #e74c3c; padding: 5px 15px; border-radius: 5px; cursor: pointer; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { flex: 1; padding: 12px; background: #0f3460; border: none; color: #aaa; cursor: pointer; border-radius: 8px; font-weight: bold; min-width: 80px; }
        .tab-btn.active { background: #e94560; color: white; transform: translateY(-3px); }
        .game-area { display: flex; gap: 20px; }
        .card-grid { flex: 2; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
        .card { background: #0f3460; border-radius: 10px; padding: 10px; text-align: center; cursor: pointer; border: 1px solid transparent; }
        .card:hover { border-color: #f1c40f; transform: translateY(-5px); }
        .card-img { width: 100%; height: 150px; object-fit: contain; background: #222; border-radius: 5px; }
        .btn-action { width: 100%; padding: 8px; margin-top: 5px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; background: #c0392b; color: white; }
        .battle-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15, 15, 30, 0.98); z-index: 2000; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .battle-header { width: 100%; max-width: 800px; display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 1.5em; font-weight: bold; color: #f1c40f; }
        .battle-timer { font-family: monospace; font-size: 1.5em; color: #e74c3c; border: 2px solid #e74c3c; padding: 5px 15px; border-radius: 10px; background: rgba(0,0,0,0.5); }
        .battle-arena { display: flex; justify-content: space-between; width: 100%; max-width: 900px; height: 350px; align-items: flex-end; }
        .fighter { width: 45%; text-align: center; position: relative; transition: 0.3s; }
        .fighter img { width: 100%; height: 200px; object-fit: contain; drop-shadow: 0 10px 10px rgba(0,0,0,0.5); }
        .fighter-stats { background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px; margin-bottom: 10px; border: 1px solid #666; }
        .fighter-name { font-weight: bold; font-size: 1.2em; color: #fff; margin-bottom: 5px; }
        .battle-menu { width: 100%; max-width: 800px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .move-btn { padding: 15px; background: #34495e; border: 1px solid #555; color: white; border-radius: 8px; text-align: left; cursor: pointer; }
        .move-btn:hover { background: #3d566e; }
        .move-btn:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }
        .move-info { font-size: 0.8em; color: #aaa; margin-top: 4px; }
        .victory-modal, .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; display: flex; flex-direction: column; justify-content: center; align-items: center; animation: fadeIn 0.5s; }
        .modal-box { background: #16213e; border: 3px solid #f1c40f; padding: 30px; border-radius: 20px; text-align: center; width: 320px; animation: popIn 0.3s; }
        .btn-yes { background: #27ae60; padding: 10px 20px; border:none; color:white; border-radius:5px; cursor:pointer; margin:5px; }
        .btn-no { background: #7f8c8d; padding: 10px 20px; border:none; color:white; border-radius:5px; cursor:pointer; margin:5px; }
        .floating-damage { position: absolute; color: #ffeb3b; font-weight: bold; font-size: 32px; animation: floatUp 2.0s forwards; z-index: 3000; text-shadow: 2px 2px 0 #000; }
        .levelup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(241, 196, 15, 0.9); z-index: 6000; display: flex; justify-content: center; align-items: center; flex-direction: column; animation: popIn 0.5s; }
        .gacha-box { text-align: center; padding: 40px; background: #16213e; border-radius: 15px; }
        .gacha-btn { width: 80%; margin: 10px auto; padding: 15px; border-radius: 50px; border: none; cursor: pointer; font-size: 1.2em; background: linear-gradient(45deg, #f1c40f, #d35400); color: white; }
        .level-selector { margin-bottom: 15px; text-align: center; background: #2c3e50; padding: 10px; border-radius: 8px; border: 1px solid #444; }
        .level-selector select { padding: 5px 10px; border-radius: 5px; border: none; background: #16213e; color: white; font-weight: bold; cursor: pointer; font-size: 1em; }
        .quest-card { border-left: 5px solid #aaa; background: #2c3e50; padding: 15px; margin-bottom: 10px; text-align: left; }
        .quest-active { border-left-color: #f1c40f; } .quest-completed { border-left-color: #2ecc71; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-80px); opacity: 0; } }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } 100% { transform: translateX(0); } }
        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        .shake-hit { animation: shake 0.4s; }
        .battle-log-panel { flex: 1; background: #16213e; border: 2px solid #0f3460; border-radius: 10px; height: 500px; padding: 10px; overflow-y: auto; position: sticky; top: 20px; }
        .log-entry { font-size: 0.9em; border-bottom: 1px solid #333; padding: 4px 0; }
        .dex-card { text-align: center; cursor: pointer; border: 2px solid transparent; } .dex-card:hover { border: 2px solid #f1c40f; }
        .dex-img { width: 100%; height: 120px; object-fit: contain; background: #222; border-radius: 5px; transition: 0.3s; }
        .dex-locked { filter: brightness(0); opacity: 0.3; }
        .dex-name { margin-top: 5px; font-weight: bold; color: #666; }
        .dex-unlocked-name { color: #f1c40f; }
        .gacha-anim-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5000; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .pokeball-anim { width: 150px; height: 150px; background: white; border: 8px solid #333; border-radius: 50%; position: relative; overflow: hidden; animation: shakeBall 1s infinite; }
        .pokeball-anim::before { content: ''; position: absolute; top: 0; width: 100%; height: 50%; background: #e74c3c; border-bottom: 8px solid #333; }
        .pokeball-anim::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; background: white; border: 6px solid #333; border-radius: 50%; z-index: 2; animation: blink 0.5s infinite alternate; }
        .gacha-text { color: white; margin-top: 20px; font-size: 1.5em; animation: pulse 1s infinite; }
        @keyframes shakeBall { 0% { transform: rotate(0deg); } 20% { transform: rotate(-15deg); } 40% { transform: rotate(15deg); } 60% { transform: rotate(-15deg); } 80% { transform: rotate(0deg); } 100% { transform: rotate(0deg); } }
        @keyframes blink { from { background: #fff; } to { background: #f1c40f; } }
        @media (max-width: 768px) { .battle-arena { height: 300px; } .fighter { width: 140px; } .fighter img { height: 140px; } .battle-menu { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div id="app" class="container">
    
    <div class="navbar" v-if="user">
        <div class="user-info">
            <img :src="user.pokemon_image" class="user-avatar">
            <div class="user-stats">
                <div>{{ user.username }} (Lv.{{ user.level }}) ğŸ’° {{ user.money }}</div>
                <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(user) + '%' }"></div></div>
                <div class="bar-text"><span>HP: {{ user.hp }}/{{ user.max_hp }}</span><span class="atk-val">ATK: {{ user.attack }}</span></div>
                <div class="bar-container"><div class="bar-fill pet-xp-fill" :style="{ width: petXpPercent(user) + '%' }"></div></div>
                <div class="bar-text"><span>{{ user.pokemon_name }} Lv.{{ user.pet_level }}</span><span>XP: {{ user.pet_exp }}/{{ user.next_pet_level_exp }}</span></div>
            </div>
        </div>
        <button class="btn-logout" @click="logout">ç™»å‡º</button>
    </div>

    <div v-if="!user" style="text-align:center; padding:100px;">
        <h2 style="color:#f1c40f;">æ­£åœ¨é€£ç·šåˆ°ä¼ºæœå™¨...</h2>
        <button class="btn-logout" @click="logout" style="margin-top:20px;">å›ç™»å…¥é é‡è©¦</button>
    </div>

    <div v-if="showLevelUp" class="levelup-overlay"><div style="font-size:5em; font-weight:bold; color:#fff">LEVEL UP!</div><div style="font-size:2em; margin-top:20px; color:#fff">ç­‰ç´šæå‡ï¼</div></div>
    <div v-if="inviteState.show" class="modal-overlay"><div class="modal-box"><h3>ğŸ’Œ æ±ºé¬¥é‚€è«‹</h3><p>{{ inviteState.senderName }} å‘ä½ ç™¼èµ·æŒ‘æˆ°ï¼</p><div class="modal-btns"><button class="btn-yes" @click="respondInvite(true)">æ¥å—</button><button class="btn-no" @click="respondInvite(false)">æ‹’çµ•</button></div></div></div>
    <div v-if="gachaResult.show" class="modal-overlay"><div class="modal-box"><h3>ğŸ‰ ç²å¾—æ–°å¤¥ä¼´ï¼</h3><img :src="gachaResult.prize.img" class="modal-img"><p>ç²å¾— <b>{{ gachaResult.prize.name }}</b>ï¼</p><div class="modal-btns"><button class="btn-yes" @click="confirmSwap(true)">è®Šèº«</button><button class="btn-no" @click="confirmSwap(false)">æ”¶ä¸‹</button></div></div></div>
    <div v-if="isGachaAnimating" class="gacha-anim-overlay"><div class="pokeball-anim"></div><div class="gacha-text">æ•æ‰ä¸­...</div></div>

    <h1 style="text-align: center; color: #e94560;" v-if="user && !battleState.isActive">âš”ï¸ å¦™è›™å®¸çš„ç†±è¡€æˆ°å ´ âš”ï¸</h1>

    <div v-if="battleState.isActive" class="battle-overlay">
        <div class="battle-header"><h3>{{ battleState.mode==='wild'?'ğŸŒ² é‡ç”Ÿé­é‡':'ğŸŸï¸ PVPå°æ±º' }}</h3><div class="battle-timer" v-if="!battleState.winner">â±ï¸ {{ battleState.timer }}</div></div>
        <div class="battle-arena">
            <div class="fighter" :class="{'shake-hit': battleState.shakeMe}">
                <img :src="user.pokemon_image" id="fighter-me">
                <div>{{ user.username }} (Lv.{{ user.pet_level }})</div>
                <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(user) + '%' }"></div></div>
                <small>{{ user.hp }} / {{ user.max_hp }}</small>
                <div style="color:#f1c40f; font-weight:bold; font-size:0.9em;">ATK: {{ currentAtkMe }}</div>
            </div>
            <div class="fighter" :class="{'shake-hit': battleState.shakeTarget}">
                <img :src="battleState.target.image_url || battleState.target.pokemon_image" id="fighter-target">
                <div>{{ battleState.target.name || battleState.target.username }}</div>
                <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(battleState.target) + '%' }"></div></div>
                <small>{{ battleState.target.hp }} / {{ battleState.target.max_hp }}</small>
                <div style="color:#f1c40f; font-weight:bold; font-size:0.9em;">ATK: {{ currentAtkTarget }}</div>
            </div>
        </div>
        
        <div v-if="!battleState.winner" class="battle-menu">
            <button v-for="(move, idx) in myMoves" :key="idx" class="move-btn" 
                :disabled="!isMyTurn || battleState.isActionProcessing"
                @click="executePlayerMove(move)">
                <div>{{ move.name }} <span style="float:right; color:#f1c40f">å¨åŠ›: {{ calculateDisplayDmg(currentAtkMe, move.dmg) }}</span></div>
                <div class="move-info">{{ move.desc }}</div>
            </button>
            <button class="move-btn" style="background:#2980b9" 
                :disabled="!isMyTurn || battleState.isActionProcessing || battleState.defenseCount <= 0"
                @click="executeDefense">
                <div>ğŸ›¡ï¸ é˜²ç¦¦</div><div class="move-info">æœ¬å›åˆç„¡å‚· + 30%åå‚·</div>
            </button>
        </div>
        <div v-else class="modal-overlay">
            <div class="modal-box"><h3>{{ battleState.winner === 'player' ? 'ğŸ† å‹åˆ©ï¼' : 'ğŸ’€ å¤±æ•—...' }}</h3><button class="btn-yes" @click="endBattle">é›¢é–‹</button></div>
        </div>
    </div>

    <div class="tabs" v-if="user && !battleState.isActive">
        <button class="tab-btn" @click="currentTab='wild'" :class="{active: currentTab=='wild'}">ğŸŒ² é‡å¤–</button>
        <button class="tab-btn" @click="currentTab='arena'" :class="{active: currentTab=='arena'}">ğŸŸï¸ ç«¶æŠ€</button>
        <button class="tab-btn" @click="currentTab='quest'" :class="{active: currentTab=='quest'}">ğŸ“œ ä»»å‹™</button>
        <button class="tab-btn" @click="currentTab='shop'" :class="{active: currentTab=='shop'}">ğŸ›’ å•†åº—</button>
        <button class="tab-btn" @click="currentTab='bag'" :class="{active: currentTab=='bag'}">ğŸ’ èƒŒåŒ…</button>
        <button class="tab-btn" @click="currentTab='dex'" :class="{active: currentTab=='dex'}">ğŸ“– åœ–é‘‘</button>
    </div>

    <div class="game-area" v-if="user && !battleState.isActive">
        <div v-if="currentTab === 'wild'" style="width:100%">
            <div class="level-selector"><label>âš”ï¸ é¸æ“‡é›£åº¦ï¼š</label><select v-model="selectedWildLevel" @change="fetchMonsters" style="margin-bottom:10px; padding:5px;"><option v-for="n in user.level" :value="n">Lv. {{ n }}</option></select></div>
            <div class="card-grid"><div v-for="m in monsters" :key="m.id" class="card"><img :src="m.image_url" class="card-img"><div class="card-body"><b>{{ m.name }}</b><br><small>XP:{{m.xp}} G:{{m.gold}}</small><br><button class="btn-action" @click="initBattle(m, 'wild')">æˆ°é¬¥</button></div></div></div>
        </div>
        <div v-if="currentTab === 'arena'" class="card-grid"><div v-for="p in players" :key="p.id" class="card"><img :src="p.pokemon_image" class="card-img"><div class="card-body"><b>{{ p.username }}</b> (Lv.{{ p.level }})<br><button class="btn-action" v-if="p.is_online" @click="sendInvite(p)">é‚€è«‹</button><button v-else class="btn-action" disabled style="background:#555">é›¢ç·š</button></div></div></div>
        <div v-if="currentTab === 'quest'" style="width:100%"><div v-for="q in quests" :key="q.id" class="card quest-card" :class="{'quest-active': q.status=='ACTIVE', 'quest-completed': q.status=='COMPLETED'}"><h4>æ“Šæ•— {{ q.req }} éš» Lv.{{ q.target_lv }} {{ q.target }}</h4><p>çå‹µ: {{ q.gold }}G, {{ q.xp }}XP</p><button v-if="q.status=='WAITING'" class="btn-action" style="background:#3498db" @click="acceptQuest(q.id)">æ¥å—ä»»å‹™</button><button v-if="q.status=='ACTIVE'" class="btn-action" disabled style="background:#555">é€²è¡Œä¸­ ({{ q.now }}/{{ q.req }})</button><button v-if="q.status=='COMPLETED'" class="btn-action" style="background:#2ecc71" @click="claimQuest(q.id)">é ˜å–çå‹µ</button></div></div>
        <div v-if="currentTab === 'shop'" style="width:100%; text-align:center"><div class="gacha-box"><h3>æ‰­è›‹æ©Ÿ</h3><button class="gacha-btn" @click="playGacha('normal')">ğŸ”® åˆç´š (2000G)</button><button class="gacha-btn" style="background:linear-gradient(45deg, #e91e63, #9c27b0)" @click="playGacha('candy')">ğŸ¬ ç³–æœ (10 ç³–æœ)</button><br><br><button class="btn-action" style="width:200px; background:#27ae60" @click="buyHeal">ğŸ’Š è£œè¡€ (50G)</button></div></div>
        <div v-if="currentTab === 'bag'" style="width:100%"><div class="inv-item" style="background:#2c3e50; padding:15px; border-radius:10px;"><span>ğŸ¬ ç¥å¥‡ç³–æœ</span> <span style="float:right; font-weight:bold; color:#f1c40f">x {{ inventory.candy || 0 }}</span></div></div>
        <div v-if="currentTab === 'dex'" class="card-grid"><div v-for="(p, name) in ALL_POKEMON" :key="name" class="card" @click="swapFromDex(name)"><img :src="p.img" class="card-img" :style="{filter: isUnlocked(name)?'none':'brightness(0)'}"><div class="card-body"><b>{{ isUnlocked(name) ? name : '???' }}</b></div></div></div>
        <div class="battle-log-panel"><h3 class="log-title">ğŸ“œ æˆ°é¬¥ç´€éŒ„</h3><div v-for="(log, index) in logs" :key="index" class="log-entry" v-html="log"></div></div>
    </div>
</div>

<script>
    const { createApp, ref, onMounted, computed, watch } = Vue;
    const API_URL = `https://mwtpokemons.zeabur.app/api/v1`;
    const WS_URL = `wss://mwtpokemons.zeabur.app/ws`;

    const MOVES_DB = {
        "å¦™è›™ç¨®å­": [{name:"è—¤é­",dmg:16,chance:0.35,buff:0.25,desc:"16å‚·,35%æ”»+25%"}, {name:"ç¨®å­ç‚¸å½ˆ",dmg:26,desc:"26å‚·"}, {name:"æ±¡æ³¥ç‚¸å½ˆ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}],
        "å°ç«é¾": [{name:"ç«èŠ±",dmg:16,chance:0.35,buff:0.25,desc:"16å‚·,35%æ”»+25%"}, {name:"å™´å°„ç«ç„°",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"ç«ç„°è¼ª",dmg:26,desc:"26å‚·"}],
        "å‚‘å°¼é¾œ": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.2,desc:"14å‚·,50%å›20%è¡€"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ°´æµå°¾",dmg:26,desc:"26å‚·"}],
        "çš®å¡ä¸˜": [{name:"é›»å…‰",dmg:16,chance:0.35,buff:0.25,desc:"16å‚·,35%æ”»+25%"}, {name:"æ”¾é›»",dmg:26,desc:"26å‚·"}, {name:"é›»æ“Š",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}],
        "ä¼Šå¸ƒ": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}, {name:"æŒ–æ´",dmg:16,chance:0.35,buff:0.25,desc:"16å‚·,35%æ”»+25%"}, {name:"é«˜é€Ÿæ˜Ÿæ˜Ÿ",dmg:26,desc:"26å‚·"}],
        "å¤§è”¥é´¨": [{name:"å•„",dmg:24,desc:"24å‚·"}, {name:"è‘‰åˆƒ",dmg:24,desc:"24å‚·"}, {name:"å‹‡é³¥çŒ›æ”»",dmg:36,selfDmg:0.15,desc:"36å‚·,è‡ªæ15%"}],
        "å‘†å‘†ç¸": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.2,desc:"14å‚·,50%å›20%è¡€"}, {name:"å¹»è±¡å…‰ç·š",dmg:26,desc:"26å‚·"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}],
        "å¯é”é´¨": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.2,desc:"14å‚·,50%å›20%è¡€"}, {name:"å¹»è±¡å…‰ç·š",dmg:26,desc:"26å‚·"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}],
        "å¡æ¯”ç¸": [{name:"æ³°å±±å£“é ‚",dmg:26,desc:"26å‚·"}, {name:"åœ°éœ‡",dmg:16,chance:0.35,heal:0.25,desc:"16å‚·,35%å›25%è¡€"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}],
        "å‰åˆ©è›‹": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}],
        "å¹¸ç¦è›‹": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}],
        "å¿«é¾": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"é€†é±—",dmg:28,desc:"28å‚·"}, {name:"å‹‡é³¥çŒ›æ”»",dmg:36,selfDmg:0.15,desc:"36å‚·,è‡ªæ15%"}],
        "default": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}]
    };
    
    const WILD_MOVES = {
        "å°æ‹‰é”": [{name:"æŠ“",dmg:26},{name:"å‡ºå¥‡ä¸€æ“Š",dmg:26},{name:"æ’æ“Š",dmg:24}],
        "æ³¢æ³¢": [{name:"æŠ“",dmg:26},{name:"å•„",dmg:24},{name:"ç‡•è¿”",dmg:26}],
        "çƒˆé›€": [{name:"æŠ“",dmg:26},{name:"å•„",dmg:24},{name:"ç‡•è¿”",dmg:26}],
        "é˜¿æŸè›‡": [{name:"æ¯’é‡",dmg:14,chance:0.5,buff:0.25},{name:"æ¯’æ“Š",dmg:26},{name:"ç·ŠæŸ",dmg:24}],
        "ç“¦æ–¯å½ˆ": [{name:"æ¯’é‡",dmg:14,chance:0.5,buff:0.25},{name:"æ’æ“Š",dmg:24}],
        "æµ·æ˜Ÿæ˜Ÿ": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.2},{name:"å¹»è±¡å…‰ç·š",dmg:26},{name:"æ’æ“Š",dmg:24}],
        "è§’é‡‘é­š": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.2},{name:"å¹»è±¡å…‰ç·š",dmg:26},{name:"æ³¥å·´å°„æ“Š",dmg:18,chance:0.3,buff:0.2}],
        "èµ°è·¯è‰": [{name:"ç¨®å­ç‚¸å½ˆ",dmg:26},{name:"æ’æ“Š",dmg:24},{name:"æ¯’æ“Š",dmg:26}],
        "ç©¿å±±é¼ ": [{name:"æŠ“",dmg:26},{name:"æ³¥å·´å°„æ“Š",dmg:18,chance:0.3,buff:0.2},{name:"æ³¥å·´ç‚¸å½ˆ",dmg:26}],
        "èšŠé¦™å‹‡å£«": [{name:"é›™å€å¥‰é‚„",dmg:28},{name:"å†°å‡å…‰æŸ",dmg:26},{name:"æ°´æ§",dmg:14}],
        "å°ç£æ€ª": [{name:"é›»æ“Š",dmg:18},{name:"æ”¾é›»",dmg:26},{name:"æ’æ“Š",dmg:24}],
        "å¡æ‹‰å¡æ‹‰": [{name:"æ³¥å·´å°„æ“Š",dmg:18},{name:"æ³¥å·´ç‚¸å½ˆ",dmg:26},{name:"æŒ–æ´",dmg:16}],
        "å–µå–µ": [{name:"æŠ“",dmg:26},{name:"å‡ºå¥‡ä¸€æ“Š",dmg:26},{name:"æ’æ“Š",dmg:24}],
        "ç‘ªç‘™æ°´æ¯": [{name:"æ°´æ§",dmg:14},{name:"æ°´æµå°¾",dmg:26},{name:"ç·ŠæŸ",dmg:24}],
        "æš´é¯‰é¾": [{name:"æ°´æ§",dmg:14},{name:"æ°´æµå°¾",dmg:26},{name:"é€†é±—",dmg:28}]
    };

    const ALL_POKEMON = { "å¦™è›™ç¨®å­":{img:"https://img.pokemondb.net/artwork/large/bulbasaur.jpg"}, "å°ç«é¾":{img:"https://img.pokemondb.net/artwork/large/charmander.jpg"}, "å‚‘å°¼é¾œ":{img:"https://img.pokemondb.net/artwork/large/squirtle.jpg"}, "çš®å¡ä¸˜":{img:"https://img.pokemondb.net/artwork/large/pikachu.jpg"}, "å¡æ‹‰å¡æ‹‰":{img:"https://img.pokemondb.net/artwork/large/cubone.jpg"}, "å–µå–µ":{img:"https://img.pokemondb.net/artwork/large/meowth.jpg"}, "æ³¢æ³¢":{img:"https://img.pokemondb.net/artwork/large/pidgey.jpg"}, "æµ·æ˜Ÿæ˜Ÿ":{img:"https://img.pokemondb.net/artwork/large/staryu.jpg"}, "ä¼Šå¸ƒ":{img:"https://img.pokemondb.net/artwork/large/eevee.jpg"}, "å¤§è”¥é´¨":{img:"https://img.pokemondb.net/artwork/large/farfetchd.jpg"}, "å‘†å‘†ç¸":{img:"https://img.pokemondb.net/artwork/large/slowpoke.jpg"}, "å¯é”é´¨":{img:"https://img.pokemondb.net/artwork/large/psyduck.jpg"}, "å¡æ¯”ç¸":{img:"https://img.pokemondb.net/artwork/large/snorlax.jpg"}, "å‰åˆ©è›‹":{img:"https://img.pokemondb.net/artwork/large/chansey.jpg"}, "å¹¸ç¦è›‹":{img:"https://img.pokemondb.net/artwork/large/blissey.jpg"}, "å¿«é¾":{img:"https://img.pokemondb.net/artwork/large/dragonite.jpg"} };

    createApp({
        setup() {
            const user = ref(null); const token = localStorage.getItem('token');
            const monsters = ref([]); const players = ref([]); const quests = ref([]);
            const currentTab = ref('wild');
            const battleState = ref({ isActive: false, isActionProcessing: false, mode: 'wild', target: null, turn: 'player', timer: 10, defenseCount: 2, isDefending: false, winner: null, shakeMe: false, shakeTarget: false, buffs: { me: 0, target: 0 }, leechSeed: { onMe: false, onTarget: false }, turnCount: 0 });
            const inviteState = ref({ show: false, senderId: null, senderName: '' });
            const gachaResult = ref({ show: false, prize: null, isNew: false });
            const isGachaAnimating = ref(false); const selectedWildLevel = ref(1); const showLevelUp = ref(false);
            const inventory = computed(() => user.value && user.value.inventory ? JSON.parse(user.value.inventory) : {});
            let socket = null; let timerInterval = null;

            const myMoves = computed(() => user.value ? (MOVES_DB[user.value.pokemon_name] || MOVES_DB['default']) : []);
            const isMyTurn = computed(() => battleState.value.turn === 'player' && !battleState.value.winner);
            const petXpPercent = (u) => Math.min(100, (u.pet_exp / (u.next_pet_level_exp || 9999)) * 100);
            const currentAtkMe = computed(() => user.value ? Math.floor(user.value.attack * (1 + battleState.value.buffs.me)) : 0);
            const currentAtkTarget = computed(() => battleState.value.target ? Math.floor(battleState.value.target.attack * (1 + battleState.value.buffs.target)) : 0);

            if (!token) window.location.href = 'login.html';
            onMounted(async () => { await updateUserInfo(); await fetchMonsters(); await fetchPlayers(); connectWebSocket(); });
            watch(() => user.value?.pet_level, (newLv, oldLv) => { if(oldLv && newLv > oldLv) { showLevelUp.value = true; setTimeout(() => showLevelUp.value = false, 3000); } });

            const updateUserInfo = async () => { const res = await fetch(`${API_URL}/auth/me`, { headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { user.value = await res.json(); if(!selectedWildLevel.value) selectedWildLevel.value = user.value.level; } };
            const fetchMonsters = async () => { const lv = selectedWildLevel.value || 1; const res = await fetch(`${API_URL}/items/wild?level=${lv}`, { headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) monsters.value = await res.json(); };
            const fetchPlayers = async () => { const res = await fetch(`${API_URL}/auth/all`); if(res.ok) { const data = await res.json(); players.value = data.filter(u => u.id !== user.value?.id).sort((a,b) => b.is_online - a.is_online); } };
            const fetchQuests = async () => { const res = await fetch(`${API_URL}/quests/`, { headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) quests.value = await res.json(); };
            const acceptQuest = async (qid) => { const res = await fetch(`${API_URL}/quests/accept/${qid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { alert("ä»»å‹™å·²æ¥å—"); fetchQuests(); } else { const d = await res.json(); alert(d.detail); } };
            const claimQuest = async (qid) => { const res = await fetch(`${API_URL}/quests/claim/${qid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); const d = await res.json(); if(res.ok) { alert(d.message); updateUserInfo(); fetchQuests(); } else alert(d.detail); };

            const initBattle = (target, mode) => {
                clearInterval(timerInterval);
                if (target.hp <= 0) return alert("ç›®æ¨™å·²ç¶“å€’ä¸‹äº†");
                battleState.value = { isActive: true, isActionProcessing: false, mode: mode, target: JSON.parse(JSON.stringify(target)), turn: 'player', timer: 10, defenseCount: 2, isDefending: false, winner: null, shakeMe: false, shakeTarget: false, buffs: { me: 0, target: 0 }, leechSeed: { onMe: false, onTarget: false }, turnCount: 1 };
                if (mode === 'wild') startTimer();
            };

            const calculateRealDamage = (attackerAtk, moveDmg) => { 
                // ğŸ”¥ ä¿®æ­£ï¼šé˜²å‘†è™•ç†ï¼Œé¿å… undefined è¨ˆç®— ğŸ”¥
                const base = (attackerAtk / 100) * (moveDmg || 0); 
                return Math.floor(base * (0.95 + Math.random() * 0.1)); 
            };
            const calculateDisplayDmg = (atk, moveDmg) => Math.floor((atk / 100) * (moveDmg || 0));

            const executePlayerMove = async (move) => {
                if (!isMyTurn.value || battleState.value.isActionProcessing) return;
                
                try {
                    battleState.value.isActionProcessing = true;
                    clearInterval(timerInterval);
                    addLog(`ğŸ‘Š ä½ ä½¿ç”¨äº† [${move.name}]ï¼`);
                    
                    let atkBonus = 1 + (battleState.value.buffs.me);
                    // ğŸ”¥ ä¿®æ­£ï¼šç¢ºä¿æ”»æ“ŠåŠ›æ˜¯æœ‰æ•ˆæ•¸å­— ğŸ”¥
                    let finalDmg = calculateRealDamage((user.value.attack || 0) * atkBonus, move.dmg);
                    
                    const roll = Math.random();
                    if(move.chance === undefined || roll < move.chance) {
                        if(move.buff) { battleState.value.buffs.me += move.buff; showFloatingDamage('fighter-me', "ATK UP!", false, true); }
                        if(move.heal) { const h = Math.floor(user.value.max_hp * move.heal); user.value.hp = Math.min(user.value.max_hp, user.value.hp + h); showFloatingDamage('fighter-me', h, false, true); }
                    }
    
                    if(move.selfDmg) { const s = Math.floor(user.value.max_hp * move.selfDmg); user.value.hp = Math.max(0, user.value.hp - s); showFloatingDamage('fighter-me', s, false); }
    
                    if(move.dmg > 0) {
                        battleState.value.shakeTarget = true; setTimeout(() => battleState.value.shakeTarget = false, 500);
                        showFloatingDamage('fighter-target', finalDmg, false);
                        battleState.value.target.hp = Math.max(0, battleState.value.target.hp - finalDmg);
                    }
    
                    if (battleState.value.mode === 'wild') {
                        if (battleState.value.target.hp <= 0) {
                            let targetLv = 1; 
                            const match = battleState.value.target.name.match(/Lv\.(\d+)/); 
                            if(match) targetLv = parseInt(match[1]);
                            await fetch(`${API_URL}/items/wild/attack`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ monster_name: battleState.value.target.name, is_dead: true, level: targetLv }) });
                        }
                        if(!checkWinCondition()) { 
                            battleState.value.turn = 'enemy'; 
                            setTimeout(executeEnemyTurn, 1000); 
                        }
                    } else {
                        await fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } });
                        battleState.value.turn = 'enemy';
                    }
                } catch(e) { console.error(e); } 
                finally { battleState.value.isActionProcessing = false; }
            };

            const executeDefense = () => { 
                if (battleState.value.defenseCount <= 0 || battleState.value.isActionProcessing) return; 
                clearInterval(timerInterval); 
                battleState.value.defenseCount--; 
                battleState.value.isDefending = true; 
                addLog(`ğŸ›¡ï¸ ä½ æ¡å–äº†é˜²ç¦¦æ¶å‹¢ï¼`); 
                battleState.value.turn = 'enemy'; 
                if(battleState.value.mode === 'wild') setTimeout(executeEnemyTurn, 1500); 
                else fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); 
            };

            const executeEnemyTurn = () => {
                if (battleState.value.winner) return;
                let enemyName = battleState.value.target.name.split('(')[0].trim().replace('ğŸ‘‘','').trim();
                const moves = WILD_MOVES[enemyName] || MOVES_DB['default'];
                const move = moves[Math.floor(Math.random() * moves.length)];
                addLog(`âš ï¸ å°æ‰‹ [${enemyName}] ä½¿ç”¨äº† [${move.name}]ï¼`);
                
                let enemyBaseAtk = battleState.value.target.attack || 50; 
                let dmg = calculateRealDamage(enemyBaseAtk * (1 + battleState.value.buffs.target), move.dmg);

                if (battleState.value.isDefending) { 
                    const reflect = Math.floor(dmg * 0.3); dmg = 0; 
                    battleState.value.target.hp = Math.max(0, battleState.value.target.hp - reflect); 
                    showFloatingDamage('fighter-target', reflect, false); 
                    addLog(`ğŸ›¡ï¸ é˜²ç¦¦æˆåŠŸï¼åå½ˆäº† ${reflect} å‚·å®³ï¼`); 
                    battleState.value.isDefending = false; 
                }
                
                if(dmg > 0) {
                    battleState.value.shakeMe = true; setTimeout(() => battleState.value.shakeMe = false, 500);
                    showFloatingDamage('fighter-me', dmg, true);
                    user.value.hp = Math.max(0, user.value.hp - dmg);
                }
                
                if (battleState.value.mode === 'wild' && battleState.value.target.hp <= 0) {
                     let targetLv = 1; const match = battleState.value.target.name.match(/Lv\.(\d+)/); if(match) targetLv = parseInt(match[1]);
                     fetch(`${API_URL}/items/wild/attack`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ monster_name: battleState.value.target.name, is_dead: true, level: targetLv }) });
                }
                if(!checkWinCondition()) { battleState.value.turn = 'player'; startTimer(); }
            };

            // ğŸ”¥ ç¢ºä¿å‡½å¼æœ‰æ­£ç¢ºåŒ¯å‡º ğŸ”¥
            const endBattle = async () => { clearInterval(timerInterval); if (battleState.value.mode === 'pvp') await fetch(`${API_URL.replace('/items', '')}/shop/duel/end/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); battleState.value.isActive = false; battleState.value.winner = null; updateUserInfo(); };

            const startTimer = () => { clearInterval(timerInterval); battleState.value.timer = 10; timerInterval = setInterval(() => { if (!battleState.value.isActive) { clearInterval(timerInterval); return; } battleState.value.timer--; if (battleState.value.timer <= 0) { clearInterval(timerInterval); if(battleState.value.mode === 'wild') { battleState.value.turn = 'enemy'; setTimeout(executeEnemyTurn, 1000); } else { fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); battleState.value.turn = 'enemy'; } } }, 1000); };
            const checkWinCondition = () => { if (battleState.value.target.hp <= 0) { battleState.value.winner = 'player'; return true; } if (user.value.hp <= 0) { battleState.value.winner = 'enemy'; return true; } return false; };
            const connectWebSocket = () => { socket = new WebSocket(`${WS_URL}?token=${token}`); socket.onopen = () => setInterval(() => socket.readyState===1 && socket.send("ping"), 30000); socket.onmessage = (e) => { const msg = e.data; const parts = msg.split("|"); if (msg.startsWith("ğŸ“¢")) addLog(msg); if (msg.startsWith("EVENT:DUEL_INVITE") && parseInt(parts[3]) === user.value.id) inviteState.value = { show: true, senderId: parts[1], senderName: parts[2] }; if (msg.startsWith("EVENT:DUEL_START")) { const p1=parseInt(parts[1]), p2=parseInt(parts[3]), first=parseInt(parts[5]); if(user.value.id===p1 || user.value.id===p2) { inviteState.value.show = false; const oppId = user.value.id===p1 ? p2 : p1; fetchPlayers().then(() => { const opp = players.value.find(p=>p.id===oppId); if(opp) { initBattle(opp, 'pvp'); battleState.value.turn = user.value.id===first?'player':'enemy'; if(battleState.value.turn==='player') startTimer(); } }); } } if (msg.startsWith("EVENT:PVP_MOVE")) { const targetId = parseInt(parts[2]); if (battleState.value.isActive && user.value.id === targetId) { fetchPlayers().then(() => { const opp = players.value.find(p => p.id === parseInt(parts[1])); if(opp) battleState.value.target.hp = opp.hp; const me = players.value.find(p => p.id === user.value.id); if(me) user.value.hp = me.hp; if(!checkWinCondition()) { battleState.value.turn = 'player'; startTimer(); } }); } } fetchMonsters(); fetchPlayers(); updateUserInfo(); fetchQuests(); }; };
            const playGacha = async (type) => { try { isGachaAnimating.value = true; const res = await fetch(`${API_URL.replace('/items', '')}/shop/gacha/${type}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); const data = await res.json(); setTimeout(() => { isGachaAnimating.value = false; if(res.ok) { gachaResult.value = { show: true, prize: data.prize, isNew: data.is_new }; updateUserInfo(); } else alert(data.detail); }, 2500); } catch(e) { isGachaAnimating.value = false; } };
            const confirmSwap = async (s) => { if(s) await fetch(`${API_URL.replace('/items', '')}/shop/swap/${gachaResult.value.prize.name}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); gachaResult.value.show = false; updateUserInfo(); };
            const swapFromDex = async (name) => { if (!user.value.unlocked_monsters.includes(name)) return alert("æœªè§£é–"); if(confirm(`è®Šèº« ${name}?`)) await fetch(`${API_URL.replace('/items', '')}/shop/swap/${name}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); updateUserInfo(); };
            const buyHeal = async () => { const res = await fetch(`${API_URL.replace('/items', '')}/shop/heal`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { alert("è£œè¡€æˆåŠŸ"); updateUserInfo(); } else alert("é‡‘å¹£ä¸è¶³"); };
            const logout = () => { localStorage.clear(); window.location.href = 'login.html'; };
            const addLog = (msg) => { logs.value.unshift(msg); if(logs.value.length > 50) logs.value.pop(); };
            const hpPercent = (u) => (u.hp / u.max_hp) * 100;
            const isUnlocked = (n) => user.value.unlocked_monsters.includes(n);
            const showFloatingDamage = (id, val, crit, heal) => { const el = document.createElement('div'); el.className = 'floating-damage'; el.innerText = heal?`+${val}`:(crit?`ğŸ’¥ ${val}`:`-${val}`); const rect = document.getElementById(id).getBoundingClientRect(); el.style.left = rect.left+50+'px'; el.style.top = rect.top+'px'; if(crit) el.style.color='red'; if(heal) el.style.color='green'; document.body.appendChild(el); setTimeout(()=>el.remove(),2000); };
            const getMoveClass = (move) => { if (move.type === 'buff') return 'move-buff'; if (move.type === 'heal') return 'move-heal'; return 'move-damage'; };
            
            // ğŸ”¥ ä¿®æ­£ï¼šç¢ºä¿ sendInvite è¢«æ­£ç¢ºå®šç¾©ä¸¦åŒ¯å‡º ğŸ”¥
            const sendInvite = async (p) => { await fetch(`${API_URL.replace('/items', '')}/shop/duel/invite/${p.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); alert("å·²é‚€è«‹"); };
            
            watch(currentTab, (n) => { if(n=='wild') fetchMonsters(); if(n=='arena') fetchPlayers(); if(n=='quest') fetchQuests(); });

            return { user, monsters, players, quests, inventory, currentTab, battleState, myMoves, isMyTurn, inviteState, gachaResult, ALL_POKEMON, hpPercent, petXpPercent, logout, initBattle, executePlayerMove, executeDefense, endBattle, playGacha, buyHeal, sendInvite, respondInvite, confirmSwap, swapFromDex, isUnlocked, isGachaAnimating, acceptQuest, claimQuest, selectedWildLevel, fetchMonsters, currentAtkMe, currentAtkTarget, calculateDisplayDmg, showLevelUp };
        }
    }).mount('#app');
</script>