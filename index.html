<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>âš¡ï¸ å¯¶å¯å¤¢å¤§äº‚é¬¥ (V25 å¥½å‹ç¤¾äº¤ç‰ˆ) âš¡ï¸</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #1a1a2e; color: #fff; padding: 20px; user-select: none; }
        .container { max-width: 900px; margin: 0 auto; }
        
        /* Navbar */
        .navbar { display: flex; justify-content: space-between; align-items: center; background: #16213e; padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #0f3460; }
        .user-info { display: flex; gap: 15px; width: 100%; }
        .user-avatar { width: 70px; height: 70px; border-radius: 50%; border: 3px solid #f1c40f; object-fit: cover; }
        .user-stats { flex: 1; display: flex; flex-direction: column; gap: 8px; }
        .stat-block { background: rgba(0,0,0,0.2); padding: 5px 10px; border-radius: 5px; }
        .stat-title { font-size: 0.9em; color: #aaa; margin-bottom: 2px; display: flex; justify-content: space-between; }
        .bar-container { width: 100%; background: #333; height: 8px; border-radius: 4px; overflow: hidden; position: relative; }
        .bar-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: linear-gradient(90deg, #e74c3c, #c0392b); } 
        .pet-xp-fill { background: linear-gradient(90deg, #3498db, #2980b9); } 
        .player-xp-fill { background: linear-gradient(90deg, #f1c40f, #d35400); }
        .bar-text { font-size: 0.75em; color: #ccc; display: flex; justify-content: space-between; margin-top: 1px; }
        .atk-val { color: #f1c40f; font-weight: bold; }
        .btn-logout { background: transparent; border: 1px solid #e74c3c; color: #e74c3c; padding: 5px 15px; border-radius: 5px; cursor: pointer; align-self: flex-start; }
        
        /* Tabs */
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { flex: 1; padding: 12px; background: #0f3460; border: none; color: #aaa; cursor: pointer; border-radius: 8px; font-weight: bold; min-width: 80px; transition:0.2s; display:flex; flex-direction:column; align-items:center; justify-content: center; }
        .tab-btn.active { background: #e94560; color: white; transform: translateY(-3px); }
        .tab-sub { font-size: 0.7em; margin-top: 2px; opacity: 0.8; }
        
        /* Game Area */
        .game-area { display: flex; gap: 20px; }
        .card-grid { flex: 2; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
        .card { background: #0f3460; border-radius: 10px; padding: 10px; text-align: center; cursor: pointer; border: 1px solid transparent; transition:0.2s; position: relative; }
        .card:hover { border-color: #f1c40f; transform: translateY(-5px); }
        .card-img { width: 100%; height: 150px; object-fit: contain; background: #222; border-radius: 5px; }
        .btn-action { width: 100%; padding: 8px; margin-top: 5px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; background: #c0392b; color: white; }
        .btn-small { width: 48%; padding: 5px; font-size: 0.9em; margin-top: 5px; border: none; border-radius: 5px; cursor: pointer; color: white; }
        .level-selector { margin-bottom: 15px; text-align: center; background: #2c3e50; padding: 10px; border-radius: 8px; border: 1px solid #444; }
        .level-selector select { padding: 5px 10px; border-radius: 5px; border: none; background: #16213e; color: white; font-weight: bold; cursor: pointer; font-size: 1em; }
        
        /* Social & Quest */
        .quest-card, .social-card { border-left: 5px solid #aaa; background: #2c3e50; padding: 15px; margin-bottom: 10px; text-align: left; border-radius: 5px; }
        .quest-active { border-left-color: #f1c40f; } .quest-completed { border-left-color: #2ecc71; }
        .quest-golden { background: linear-gradient(45deg, #f1c40f, #f39c12); color: #000; border-left: 5px solid #fff; border: 2px solid #fff; box-shadow: 0 0 15px rgba(241, 196, 15, 0.5); }
        .inv-item { background: #2c3e50; padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        
        /* Gacha & Battle */
        .gacha-box { text-align: center; padding: 40px; background: #16213e; border-radius: 15px; position: relative; }
        .gacha-btn { width: 80%; margin: 10px auto; padding: 15px; border-radius: 50px; border: none; cursor: pointer; font-size: 1.2em; background: linear-gradient(45deg, #f1c40f, #d35400); color: white; transition: 0.3s; }
        .gacha-btn:hover { transform: scale(1.05); }
        .battle-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15, 15, 30, 0.98); z-index: 2000; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .battle-header { width: 100%; max-width: 800px; display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 1.5em; font-weight: bold; color: #f1c40f; }
        .battle-timer { font-family: monospace; font-size: 1.5em; color: #e74c3c; border: 2px solid #e74c3c; padding: 5px 15px; border-radius: 10px; background: rgba(0,0,0,0.5); }
        .battle-arena { display: flex; justify-content: space-between; width: 100%; max-width: 900px; height: 350px; align-items: flex-end; }
        .fighter { width: 45%; text-align: center; position: relative; transition: 0.3s; }
        .fighter img { width: 100%; height: 200px; object-fit: contain; drop-shadow: 0 10px 10px rgba(0,0,0,0.5); }
        .fighter-stats { background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px; margin-bottom: 10px; border: 1px solid #666; }
        .fighter-name { font-weight: bold; font-size: 1.2em; color: #fff; margin-bottom: 5px; }
        .battle-menu { width: 100%; max-width: 800px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .move-btn { padding: 15px; background: #34495e; border: 1px solid #555; color: white; border-radius: 8px; text-align: left; cursor: pointer; transition: 0.2s; }
        .move-btn:hover:not(.cooldown) { background: #3d566e; transform: translateY(-2px); }
        .move-btn.cooldown { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }
        .move-info { font-size: 0.8em; color: #aaa; margin-top: 4px; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 4000; display: flex; justify-content: center; align-items: center; }
        .modal-box { background: #16213e; border: 3px solid #f1c40f; padding: 30px; border-radius: 20px; text-align: center; width: 300px; animation: popIn 0.3s; position: relative; }
        .modal-title { font-size: 1.5em; color: #f1c40f; margin-bottom: 20px; }
        .modal-img { max-width: 100%; max-height: 200px; object-fit: contain; margin-bottom: 15px; display: block; margin: 0 auto 15px auto; }
        .modal-btns { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        .btn-yes { background: #27ae60; padding: 10px 20px; border:none; color:white; border-radius:5px; cursor:pointer; margin:5px; }
        .btn-no { background: #7f8c8d; padding: 10px 20px; border:none; color:white; border-radius:5px; cursor:pointer; margin:5px; }
        
        .floating-damage { position: absolute; color: #ffeb3b; font-weight: bold; font-size: 32px; animation: floatUp 2.0s forwards; z-index: 3000; text-shadow: 2px 2px 0 #000; pointer-events: none; }
        .levelup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(241, 196, 15, 0.9); z-index: 6000; display: flex; justify-content: center; align-items: center; flex-direction: column; animation: popIn 0.5s; pointer-events: none; }
        .levelup-text { font-size: 4em; font-weight: bold; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin-bottom: 20px; }
        .levelup-sub { font-size: 2em; color: #fff; }
        
        .gacha-anim-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5000; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .pokeball-anim { width: 150px; height: 150px; background: white; border: 8px solid #333; border-radius: 50%; position: relative; overflow: hidden; animation: shakeBall 1s infinite; }
        .pokeball-anim::before { content: ''; position: absolute; top: 0; width: 100%; height: 50%; background: #e74c3c; border-bottom: 8px solid #333; }
        .pokeball-anim::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; background: white; border: 6px solid #333; border-radius: 50%; z-index: 2; animation: blink 0.5s infinite alternate; }
        .gacha-text { color: white; margin-top: 20px; font-size: 1.5em; animation: pulse 1s infinite; }
        
        .battle-log-panel { flex: 1; background: #16213e; border: 2px solid #0f3460; border-radius: 10px; height: 500px; padding: 10px; overflow-y: auto; position: sticky; top: 20px; }
        .log-entry { font-size: 0.9em; border-bottom: 1px solid #333; padding: 4px 0; }
        .dex-card { text-align: center; cursor: pointer; border: 2px solid transparent; } .dex-card:hover { border: 2px solid #f1c40f; }
        .dex-img { width: 100%; height: 120px; object-fit: contain; background: #222; border-radius: 5px; transition: 0.3s; }
        .dex-locked { filter: brightness(0); opacity: 0.3; }
        .dex-unlocked-name { color: #f1c40f; }
        
        .rate-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .rate-table th, .rate-table td { border: 1px solid #444; padding: 8px; text-align: left; }
        .rate-table th { background: #34495e; }
        
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-80px); opacity: 0; } }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } 100% { transform: translateX(0); } }
        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        @keyframes shakeBall { 0% { transform: rotate(0deg); } 20% { transform: rotate(-15deg); } 40% { transform: rotate(15deg); } 60% { transform: rotate(-15deg); } 80% { transform: rotate(0deg); } 100% { transform: rotate(0deg); } }
        @keyframes blink { from { background: #fff; } to { background: #f1c40f; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .shake-hit { animation: shake 0.4s; }
        @media (max-width: 768px) { .battle-arena { height: 300px; } .fighter { width: 140px; } .fighter img { height: 140px; } .battle-menu { grid-template-columns: 1fr; } .game-area { flex-direction: column; } .battle-log-panel { height: 200px; } }
    </style>
</head>
<body>

<div id="app" class="container">
    
    <div v-if="!user" style="text-align:center; padding-top:100px;">
        <h2 style="color:#f1c40f">æ­£åœ¨é€£ç·šä¼ºæœå™¨...</h2>
        <p style="color:#aaa">(å¦‚æœè¶…é 5 ç§’æ²’åæ‡‰ï¼Œè«‹é»ä¸‹æ–¹æŒ‰éˆ•é‡æ–°ç™»å…¥)</p>
        <button class="btn-logout" @click="logout">å‰å¾€ç™»å…¥é é¢</button>
    </div>

    <div v-else>
        <div class="navbar">
            <div class="user-info">
                <img :src="user.pokemon_image" class="user-avatar">
                <div class="user-stats">
                    <div class="stat-block">
                        <div class="stat-title">
                            <span>{{ user.username }} (Lv.{{ user.level }})</span>
                            <span>ğŸ’° {{ user.money }}</span>
                        </div>
                        <div class="bar-container"><div class="bar-fill player-xp-fill" :style="{ width: playerXpPercent + '%' }"></div></div>
                        <div class="bar-text"><span>Trainer XP</span><span>{{ user.exp }}/{{ user.next_level_exp }}</span></div>
                    </div>

                    <div class="stat-block">
                        <div class="stat-title">
                            <span>{{ user.pokemon_name }} (Lv.{{ user.pet_level }})</span>
                            <span class="atk-val">ATK: {{ currentAtkMe }}</span>
                        </div>
                        <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(user) + '%' }"></div></div>
                        <div class="bar-text"><span>HP: {{ user.hp }}/{{ user.max_hp }}</span></div>
                        <div class="bar-container" style="margin-top:4px;"><div class="bar-fill pet-xp-fill" :style="{ width: petXpPercent(user) + '%' }"></div></div>
                        <div class="bar-text"><span>Pet XP</span><span>{{ user.pet_exp }}/{{ user.next_pet_level_exp }}</span></div>
                    </div>
                </div>
            </div>
            <button class="btn-logout" @click="logout">ç™»å‡º</button>
        </div>

        <div v-if="showLevelUp" class="levelup-overlay">
            <div class="levelup-text">LEVEL UP!</div>
            <div class="levelup-sub">æ­å–œ {{ user.username }}<br>å‡åˆ°äº† Lv.{{ user.pet_level }}ï¼</div>
        </div>
        <div v-if="rateState.show" class="modal-overlay" @click.self="rateState.show = false">
            <div class="modal-box" style="width: 400px; max-height: 80vh; overflow-y: auto;">
                <div class="modal-title">ğŸ“Š æ‰­è›‹æ©Ÿç‡è¡¨</div>
                <div v-for="(pool, name) in gachaRates" :key="name" style="margin-bottom: 15px;">
                    <h4 style="color: #f1c40f; border-bottom: 1px solid #555;">{{ name }}</h4>
                    <table class="rate-table">
                        <tr v-for="item in pool" :key="item.name">
                            <td>{{ item.name }}</td>
                            <td style="text-align: right;">{{ item.rate }}%</td>
                        </tr>
                    </table>
                </div>
                <button class="btn-yes" style="width: 100%; margin-top: 10px;" @click="rateState.show = false">é—œé–‰</button>
            </div>
        </div>
        <div v-if="inviteState.show" class="modal-overlay"><div class="modal-box"><h3>ğŸ’Œ æ±ºé¬¥é‚€è«‹</h3><p>{{ inviteState.senderName }} å‘ä½ ç™¼èµ·æŒ‘æˆ°ï¼</p><div class="modal-btns"><button class="btn-yes" @click="respondInvite(true)">æ¥å—</button><button class="btn-no" @click="respondInvite(false)">æ‹’çµ•</button></div></div></div>
        
        <div v-if="gachaResult.show" class="modal-overlay">
            <div class="modal-box">
                <div class="modal-title">{{ gachaResult.isNew ? 'ğŸ‰ ç²å¾—æ–°å¤¥ä¼´ï¼' : 'ğŸ” ç²å¾—é‡è¤‡å¤¥ä¼´' }}</div>
                <img :src="gachaResult.prize.img" class="modal-img">
                <p v-if="gachaResult.isNew">ç²å¾— <b>{{ gachaResult.prize.name }}</b>ï¼</p>
                <p v-else>ç²å¾— <b>{{ gachaResult.prize.name }}</b> (é‡è¤‡)<br><span style="color:#f1c40f; font-weight:bold;">ç¶“é©—å€¼ +500</span></p>
                <div class="modal-btns">
                    <button class="btn-yes" @click="confirmSwap(true)" v-if="gachaResult.isNew">è®Šèº«</button>
                    <button class="btn-no" @click="confirmSwap(false)">æ”¶ä¸‹</button>
                </div>
            </div>
        </div>
        
        <div v-if="isGachaAnimating" class="gacha-anim-overlay"><div class="pokeball-anim"></div><div class="gacha-text">æ•æ‰ä¸­...</div></div>

        <h1 style="text-align: center; color: #e94560;" v-if="!battleState.isActive">âš”ï¸ å¦™è›™å®¸çš„ç†±è¡€æˆ°å ´ âš”ï¸</h1>

        <div v-if="battleState.isActive" class="battle-overlay">
            <div class="battle-header"><h3>{{ battleState.mode==='wild'?'ğŸŒ² é‡ç”Ÿé­é‡':'ğŸŸï¸ PVPå°æ±º' }}</h3><div class="battle-timer" v-if="!battleState.winner">â±ï¸ {{ battleState.timer }}</div></div>
            <div class="battle-arena">
                <div class="fighter" :class="{'shake-hit': battleState.shakeMe}">
                    <img :src="user.pokemon_image" id="fighter-me">
                    <div>{{ user.username }} (Lv.{{ user.pet_level }})</div>
                    <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(user) + '%' }"></div></div>
                    <small>{{ user.hp }} / {{ user.max_hp }}</small>
                    <div style="color:#f1c40f; font-weight:bold; font-size:0.9em;">ATK: {{ currentAtkMe }}</div>
                </div>
                <div class="fighter" :class="{'shake-hit': battleState.shakeTarget}">
                    <img :src="battleState.target.image_url || battleState.target.pokemon_image" id="fighter-target">
                    <div>{{ battleState.target.name || battleState.target.username }}</div>
                    <div class="bar-container"><div class="bar-fill hp-fill" :style="{ width: hpPercent(battleState.target) + '%' }"></div></div>
                    <small>{{ battleState.target.hp }} / {{ battleState.target.max_hp }}</small>
                    <div style="color:#f1c40f; font-weight:bold; font-size:0.9em;">ATK: {{ currentAtkTarget }}</div>
                </div>
            </div>
            
            <div v-if="!battleState.winner" class="battle-menu">
                <button v-for="(move, idx) in myMoves" :key="idx" class="move-btn" 
                    :class="{'cooldown': !isMyTurn || battleState.isActionProcessing}"
                    @click="executePlayerMove(move)">
                    <div>{{ move.name }} <span style="float:right; color:#f1c40f">å¨åŠ›: {{ calculateDisplayDmg(currentAtkMe, move.dmg) }}</span></div>
                    <div class="move-info">{{ move.desc }}</div>
                </button>
                <button class="move-btn" style="background:#2980b9" 
                    :class="{'cooldown': !isMyTurn || battleState.isActionProcessing || battleState.defenseCount <= 0}"
                    @click="executeDefense">
                    <div>ğŸ›¡ï¸ é˜²ç¦¦</div><div class="move-info">æœ¬å›åˆç„¡å‚· + 30%åå‚·</div>
                </button>
            </div>
            <div v-else class="modal-overlay">
                <div class="modal-box"><h3>{{ battleState.winner === 'player' ? 'ğŸ† å‹åˆ©ï¼' : 'ğŸ’€ å¤±æ•—...' }}</h3><button class="btn-yes" @click="endBattle">é›¢é–‹</button></div>
            </div>
        </div>

        <div class="tabs" v-if="!battleState.isActive">
            <button class="tab-btn" @click="currentTab='wild'" :class="{active: currentTab=='wild'}">ğŸŒ² é‡å¤–</button>
            <button class="tab-btn" @click="currentTab='arena'" :class="{active: currentTab=='arena'}">ğŸŸï¸ ç«¶æŠ€</button>
            <button class="tab-btn" @click="currentTab='social'" :class="{active: currentTab=='social'}">ğŸ¤ å¥½å‹</button>
            <button class="tab-btn" @click="currentTab='quest'" :class="{active: currentTab=='quest'}">ğŸ“œ ä»»å‹™</button>
            <button class="tab-btn" @click="currentTab='shop'" :class="{active: currentTab=='shop'}">ğŸ›’ å•†åº—</button>
            <button class="tab-btn" @click="currentTab='bag'" :class="{active: currentTab=='bag'}">ğŸ’ èƒŒåŒ…</button>
            <button class="tab-btn" @click="currentTab='dex'" :class="{active: currentTab=='dex'}">
                ğŸ“– åœ–é‘‘
                <span class="tab-sub">({{ collectionPercent }}%)</span>
            </button>
        </div>

        <div class="game-area" v-if="!battleState.isActive">
            <div v-if="currentTab === 'wild'" style="width:100%">
                <div class="level-selector"><label>âš”ï¸ é¸æ“‡é›£åº¦ï¼š</label><select v-model="selectedWildLevel" @change="fetchMonsters" style="margin-bottom:10px; padding:5px;"><option v-for="n in user.level" :value="n">Lv. {{ n }}</option></select></div>
                <div class="card-grid"><div v-for="m in monsters" :key="m.id" class="card"><img :src="m.image_url" class="card-img"><div class="card-body"><b>{{ m.name }}</b><br><small>XP:{{m.xp}} G:{{m.gold}}</small><br><button class="btn-action" @click="initBattle(m, 'wild')">æˆ°é¬¥</button></div></div></div>
            </div>
            
            <div v-if="currentTab === 'arena'" class="card-grid">
                <div v-for="p in players" :key="p.id" class="card">
                    <img :src="p.pokemon_image" class="card-img">
                    <div class="card-body">
                        <b>{{ p.username }}</b> (Lv.{{ p.level }})
                        <div style="margin-top:5px; display:flex; gap:5px;">
                            <button class="btn-small" style="background:#c0392b" v-if="p.is_online" @click="sendInvite(p)">æ±ºé¬¥</button>
                            <button class="btn-small" style="background:#27ae60" @click="addFriend(p.id)">â• åŠ å¥½å‹</button>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="currentTab === 'social'" style="width:100%">
                <div v-if="friendRequests.length > 0">
                    <h3 style="color:#f1c40f">ğŸ“© å¥½å‹é‚€è«‹</h3>
                    <div v-for="req in friendRequests" :key="req.req_id" class="social-card" style="border-left-color:#f1c40f">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span><b>{{ req.sender_name }}</b> (Lv.{{ req.sender_lv }}) æƒ³åŠ ä½ ç‚ºå¥½å‹</span>
                            <div>
                                <button class="btn-small" style="background:#27ae60" @click="respondFriendRequest(req.req_id, true)">æ¥å—</button>
                                <button class="btn-small" style="background:#e74c3c" @click="respondFriendRequest(req.req_id, false)">æ‹’çµ•</button>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>ğŸ¤ æˆ‘çš„å¥½å‹ ({{ friends.length }})</h3>
                <div v-if="friends.length === 0" style="color:#aaa">é‚„æ²’æœ‰å¥½å‹ï¼Œå»ç«¶æŠ€å ´åŠ äººå§ï¼</div>
                <div class="card-grid">
                    <div v-for="f in friends" :key="f.id" class="card">
                        <img :src="f.img" class="card-img">
                        <div class="card-body">
                            <b>{{ f.username }}</b> (Lv.{{ f.level }})<br>
                            <small>å¤¥ä¼´: {{ f.pet }}</small>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="currentTab === 'quest'" style="width:100%">
                <div v-if="quests.length === 0" style="text-align:center; padding:20px;"><p v-if="isQuestLoading">æ­£åœ¨è®€å–ä»»å‹™...</p><p v-else>æš«ç„¡ä»»å‹™ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚</p></div>
                <div v-for="q in quests" :key="q.id" class="card quest-card" :class="{'quest-active': q.status=='ACTIVE', 'quest-completed': q.status=='COMPLETED', 'quest-golden': q.type=='GOLDEN'}">
                    <h4><span v-if="q.type=='GOLDEN'">âœ¨ é»ƒé‡‘ä»»å‹™: </span>æ“Šæ•— {{ q.req }} éš» Lv.{{ q.target_lv }} {{ q.target }}</h4>
                    <p v-if="q.type=='GOLDEN'">çå‹µ: ğŸ¬ é»ƒé‡‘ç³–æœ</p><p v-else>çå‹µ: {{ q.gold }}G, {{ q.xp }}XP</p>
                    <button v-if="q.status=='WAITING'" class="btn-action" style="background:#3498db" @click="acceptQuest(q.id)">æ¥å—ä»»å‹™</button>
                    <div v-if="q.status=='ACTIVE'"><button class="btn-action" disabled style="background:#555; margin-bottom:5px;">é€²è¡Œä¸­ ({{ q.now }}/{{ q.req }})</button><button class="btn-action" style="background:#e74c3c" @click="abandonQuest(q.id)">æ”¾æ£„</button></div>
                    <button v-if="q.status=='COMPLETED'" class="btn-action" style="background:#2ecc71" @click="claimQuest(q.id)">é ˜å–çå‹µ</button>
                </div>
            </div>
            <div v-if="currentTab === 'shop'" style="width:100%; text-align:center">
                <div class="gacha-box">
                    <h3>æ‰­è›‹æ©Ÿ <button style="font-size:0.6em; background:#555; color:white; border:none; border-radius:5px; padding:2px 5px; cursor:pointer;" @click="rateState.show=true">ğŸ“Š æŸ¥çœ‹æ©Ÿç‡</button></h3>
                    <button class="gacha-btn" @click="playGacha('normal')">ğŸ”® åˆç´š (1500G)</button>
                    <button class="gacha-btn" style="background:linear-gradient(45deg, #3498db, #2980b9)" @click="playGacha('medium')">ğŸ”µ ä¸­ç´š (3000G)</button>
                    <button class="gacha-btn" style="background:linear-gradient(45deg, #e91e63, #9c27b0)" @click="playGacha('candy')">ğŸ¬ ç³–æœ (12 ç³–æœ)</button>
                    <br><br>
                    <button class="gacha-btn" style="background:linear-gradient(45deg, #f1c40f, #d35400); margin-top:10px;" @click="playGacha('golden')">âœ¨ é»ƒé‡‘ (3 é»ƒé‡‘ç³–æœ)</button>
                    <br><br>
                    <button class="btn-action" style="width:200px; background:#27ae60" @click="buyHeal">ğŸ’Š è£œè¡€ (50G)</button>
                </div>
            </div>
            <div v-if="currentTab === 'bag'" style="width:100%"><div class="inv-item"><span>ğŸ¬ ç¥å¥‡ç³–æœ</span> <span style="float:right; font-weight:bold; color:#f1c40f">x {{ inventory.candy || 0 }}</span></div><div class="inv-item" v-if="inventory.golden_candy > 0"><span>âœ¨ é»ƒé‡‘ç³–æœ</span> <span style="float:right; font-weight:bold; color:#ffd700">x {{ inventory.golden_candy || 0 }}</span></div></div>
            <div v-if="currentTab === 'dex'" class="card-grid"><div v-for="(p, name) in ALL_POKEMON" :key="name" class="card" @click="swapFromDex(name)"><img :src="p.img" class="card-img" :style="{filter: isUnlocked(name)?'none':'brightness(0)'}"><div class="card-body"><b :class="{'dex-unlocked-name': isUnlocked(name)}">{{ isUnlocked(name) ? name : '???' }}</b></div></div></div>
            <div class="battle-log-panel"><h3 class="log-title">ğŸ“œ æˆ°é¬¥ç´€éŒ„</h3><div v-for="(log, index) in logs" :key="index" class="log-entry" v-html="log"></div></div>
        </div>
    </div>
</div>

<script>
    const { createApp, ref, onMounted, computed, watch } = Vue;
    const API_URL = `https://mwtpokemons.zeabur.app/api/v1`;
    const WS_URL = `wss://mwtpokemons.zeabur.app/ws`;

    // (MOVES_DB, WILD_MOVES, ALL_POKEMON çœç•¥)
    const MOVES_DB = { "å¦™è›™ç¨®å­": [{name:"è—¤é­",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"ç¨®å­ç‚¸å½ˆ",dmg:26,desc:"26å‚·"}, {name:"æ±¡æ³¥ç‚¸å½ˆ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "å°ç«é¾": [{name:"ç«èŠ±",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"å™´å°„ç«ç„°",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"ç«ç„°è¼ª",dmg:26,desc:"26å‚·"}], "å‚‘å°¼é¾œ": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ°´æµå°¾",dmg:26,desc:"26å‚·"}], "å¦™è›™èŠ±": [{name:"è—¤é­",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"ç¨®å­ç‚¸å½ˆ",dmg:26,desc:"26å‚·"}, {name:"æ±¡æ³¥ç‚¸å½ˆ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "å™´ç«é¾": [{name:"ç«èŠ±",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"å™´å°„ç«ç„°",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"ç«ç„°è¼ª",dmg:26,desc:"26å‚·"}], "æ°´ç®­é¾œ": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ°´æµå°¾",dmg:26,desc:"26å‚·"}], "æ¯›è¾®ç¾Š": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}, {name:"æ’’å¬Œ",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"é›»æ“Š",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "çš®å¡ä¸˜": [{name:"é›»å…‰",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"æ”¾é›»",dmg:26,desc:"26å‚·"}, {name:"é›»æ“Š",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "ä¼Šå¸ƒ": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}, {name:"æŒ–æ´",dmg:16,chance:0.35,buff:0.2,desc:"16å‚·,35%æ”»+20%"}, {name:"é«˜é€Ÿæ˜Ÿæ˜Ÿ",dmg:26,desc:"26å‚·"}], "èƒ–ä¸": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}, {name:"æ’’å¬Œ",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "çš®çš®": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}, {name:"æ’’å¬Œ",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "å¤§è”¥é´¨": [{name:"å•„",dmg:24,desc:"24å‚·"}, {name:"è‘‰åˆƒ",dmg:24,desc:"24å‚·"}, {name:"å‹‡é³¥çŒ›æ”»",dmg:36,selfDmg:0.15,desc:"36å‚·,è‡ªæ15%"}], "å‘†å‘†ç¸": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"å¹»è±¡å…‰ç·š",dmg:26,desc:"26å‚·"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "å¯é”é´¨": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"å¹»è±¡å…‰ç·š",dmg:26,desc:"26å‚·"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}], "å¡æ¯”ç¸": [{name:"æ³°å±±å£“é ‚",dmg:26,desc:"26å‚·"}, {name:"åœ°éœ‡",dmg:16,chance:0.35,heal:0.15,desc:"16å‚·,35%å›15%è¡€"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}], "å‰åˆ©è›‹": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}], "å¹¸ç¦è›‹": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"æ’æ“Š",dmg:24,desc:"24å‚·"}], "æ‹‰æ™®æ‹‰æ–¯": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"æ°´æµå™´å°„",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"å†°å‡å…‰æŸ",dmg:26,desc:"26å‚·"}], "å¿«é¾": [{name:"æŠ“",dmg:26,desc:"26å‚·"}, {name:"é€†é±—",dmg:28,desc:"28å‚·"}, {name:"å‹‡é³¥çŒ›æ”»",dmg:36,selfDmg:0.15,desc:"36å‚·,è‡ªæ15%"}], "è¶…å¤¢": [{name:"å¿µåŠ›",dmg:14,chance:0.5,heal:0.15,desc:"14å‚·,50%å›15%è¡€"}, {name:"ç²¾ç¥å¼·å¿µ",dmg:18,chance:0.3,buff:0.2,desc:"18å‚·,30%æ”»+20%"}, {name:"ç²¾ç¥æ“Šç ´",dmg:28,desc:"28å‚·"}], "default": [{name:"æ’æ“Š",dmg:24,desc:"24å‚·"}] };
    const WILD_MOVES = { "å°æ‹‰é”": [{name:"æŠ“",dmg:26},{name:"å‡ºå¥‡ä¸€æ“Š",dmg:26},{name:"æ’æ“Š",dmg:24}], "æ³¢æ³¢": [{name:"æŠ“",dmg:26},{name:"å•„",dmg:24},{name:"ç‡•è¿”",dmg:26}], "çƒˆé›€": [{name:"æŠ“",dmg:26},{name:"å•„",dmg:24},{name:"ç‡•è¿”",dmg:26}], "é˜¿æŸè›‡": [{name:"æ¯’é‡",dmg:14,chance:0.5,buff:0.2},{name:"æ¯’æ“Š",dmg:26},{name:"ç·ŠæŸ",dmg:24}], "ç“¦æ–¯å½ˆ": [{name:"æ¯’é‡",dmg:14,chance:0.5,buff:0.2},{name:"æ’æ“Š",dmg:24}], "æµ·æ˜Ÿæ˜Ÿ": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15},{name:"å¹»è±¡å…‰ç·š",dmg:26},{name:"æ’æ“Š",dmg:24}], "è§’é‡‘é­š": [{name:"æ°´æ§",dmg:14,chance:0.5,heal:0.15},{name:"å¹»è±¡å…‰ç·š",dmg:26},{name:"æ³¥å·´å°„æ“Š",dmg:18,chance:0.3,buff:0.2}], "èµ°è·¯è‰": [{name:"ç¨®å­ç‚¸å½ˆ",dmg:26},{name:"æ’æ“Š",dmg:24},{name:"æ¯’æ“Š",dmg:26}], "ç©¿å±±é¼ ": [{name:"æŠ“",dmg:26},{name:"æ³¥å·´å°„æ“Š",dmg:18,chance:0.3,buff:0.2},{name:"æ³¥å·´ç‚¸å½ˆ",dmg:26}], "èšŠé¦™å‹‡å£«": [{name:"é›™å€å¥‰é‚„",dmg:28},{name:"å†°å‡å…‰æŸ",dmg:26},{name:"æ°´æ§",dmg:14}], "å°ç£æ€ª": [{name:"é›»æ“Š",dmg:18},{name:"æ”¾é›»",dmg:26},{name:"æ’æ“Š",dmg:24}], "å¡æ‹‰å¡æ‹‰": [{name:"æ³¥å·´å°„æ“Š",dmg:18},{name:"æ³¥å·´ç‚¸å½ˆ",dmg:26},{name:"æŒ–æ´",dmg:16}], "å–µå–µ": [{name:"æŠ“",dmg:26},{name:"å‡ºå¥‡ä¸€æ“Š",dmg:26},{name:"æ’æ“Š",dmg:24}], "ç‘ªç‘™æ°´æ¯": [{name:"æ°´æ§",dmg:14},{name:"æ°´æµå°¾",dmg:26},{name:"ç·ŠæŸ",dmg:24}], "æš´é¯‰é¾": [{name:"æ°´æ§",dmg:14},{name:"æ°´æµå°¾",dmg:26},{name:"é€†é±—",dmg:28}] };
    const ALL_POKEMON = { "å¦™è›™ç¨®å­":{img:"https://img.pokemondb.net/artwork/large/bulbasaur.jpg"}, "å°ç«é¾":{img:"https://img.pokemondb.net/artwork/large/charmander.jpg"}, "å‚‘å°¼é¾œ":{img:"https://img.pokemondb.net/artwork/large/squirtle.jpg"}, "å¦™è›™èŠ±":{img:"https://img.pokemondb.net/artwork/large/venusaur.jpg"}, "å™´ç«é¾":{img:"https://img.pokemondb.net/artwork/large/charizard.jpg"}, "æ°´ç®­é¾œ":{img:"https://img.pokemondb.net/artwork/large/blastoise.jpg"}, "æ¯›è¾®ç¾Š":{img:"https://img.pokemondb.net/artwork/large/wooloo.jpg"}, "çš®å¡ä¸˜":{img:"https://img.pokemondb.net/artwork/large/pikachu.jpg"}, "ä¼Šå¸ƒ":{img:"https://img.pokemondb.net/artwork/large/eevee.jpg"}, "èƒ–ä¸":{img:"https://img.pokemondb.net/artwork/large/jigglypuff.jpg"}, "çš®çš®":{img:"https://img.pokemondb.net/artwork/large/clefairy.jpg"}, "æ³¢æ³¢":{img:"https://img.pokemondb.net/artwork/large/pidgey.jpg"}, "æµ·æ˜Ÿæ˜Ÿ":{img:"https://img.pokemondb.net/artwork/large/staryu.jpg"}, "å¤§è”¥é´¨":{img:"https://img.pokemondb.net/artwork/large/farfetchd.jpg"}, "å‘†å‘†ç¸":{img:"https://img.pokemondb.net/artwork/large/slowpoke.jpg"}, "å¯é”é´¨":{img:"https://img.pokemondb.net/artwork/large/psyduck.jpg"}, "å¡æ¯”ç¸":{img:"https://img.pokemondb.net/artwork/large/snorlax.jpg"}, "å‰åˆ©è›‹":{img:"https://img.pokemondb.net/artwork/large/chansey.jpg"}, "å¹¸ç¦è›‹":{img:"https://img.pokemondb.net/artwork/large/blissey.jpg"}, "æ‹‰æ™®æ‹‰æ–¯":{img:"https://img.pokemondb.net/artwork/large/lapras.jpg"}, "å¿«é¾":{img:"https://img.pokemondb.net/artwork/large/dragonite.jpg"}, "è¶…å¤¢":{img:"https://img.pokemondb.net/artwork/large/mewtwo.jpg"} };

    createApp({
        setup() {
            // ... (Helper Functions ä¿æŒä¸è®Š)
            const showFloatingDamage = (id, val, crit, heal) => { const el = document.createElement('div'); el.className = 'floating-damage'; el.innerText = heal ? `+${val}` : (crit ? `ğŸ’¥ ${val}` : `-${val}`); const targetEl = document.getElementById(id); if (targetEl) { const rect = targetEl.getBoundingClientRect(); el.style.left = rect.left + 50 + 'px'; el.style.top = rect.top + 'px'; if(crit) el.style.color='red'; if(heal) el.style.color='green'; document.body.appendChild(el); setTimeout(() => el.remove(), 2000); } };
            const calculateRealDamage = (attackerAtk, moveDmg) => { const dmg = moveDmg || 0; const base = (attackerAtk / 100) * dmg; return Math.floor(base * (0.95 + Math.random() * 0.1)); };
            const calculateDisplayDmg = (atk, moveDmg) => Math.floor((atk / 100) * (moveDmg || 0));

            const user = ref(null); const token = localStorage.getItem('token');
            const monsters = ref([]); const players = ref([]); const quests = ref([]);
            const friends = ref([]); const friendRequests = ref([]); // ğŸ”¥ æ–°å¢
            const currentTab = ref('wild');
            const battleState = ref({ isActive: false, isActionProcessing: false, mode: 'wild', target: null, turn: 'player', timer: 10, defenseCount: 2, isDefending: false, winner: null, shakeMe: false, shakeTarget: false, buffs: { me: 0, target: 0 }, leechSeed: { onMe: false, onTarget: false }, turnCount: 0 });
            const inviteState = ref({ show: false, senderId: null, senderName: '' });
            const gachaResult = ref({ show: false, prize: null, isNew: false });
            const rateState = ref({ show: false });
            const isGachaAnimating = ref(false); const selectedWildLevel = ref(1); const showLevelUp = ref(false);
            const isQuestLoading = ref(false);
            const inventory = computed(() => user.value && user.value.inventory ? JSON.parse(user.value.inventory) : {});
            const logs = ref([]);
            let socket = null; let timerInterval = null;

            const gachaRates = {
                "ğŸ”® åˆç´šæ‰­è›‹ (1500G)": [
                    {name: "å¤§è”¥é´¨/å‘†å‘†ç¸/å¯é”é´¨", rate: 12}, {name: "çš®çš®/èƒ–ä¸", rate: 10}, 
                    {name: "ä¼Šå¸ƒ/çš®å¡ä¸˜/æ¯›è¾®ç¾Š", rate: 8}, {name: "å¦™è›™/å°ç«é¾/å‚‘å°¼é¾œ", rate: 5},
                    {name: "å¡æ¯”ç¸/å‰åˆ©è›‹", rate: 2}
                ],
                "ğŸ”µ ä¸­ç´šæ‰­è›‹ (3000G)": [
                    {name: "å¾¡ä¸‰å®¶/ä¼Šå¸ƒ/çš®å¡/å‘†å‘†/å¯é”/æ¯›è¾®ç¾Š", rate: 10}, 
                    {name: "å¡æ¯”ç¸", rate: 5},
                    {name: "å‰åˆ©è›‹/æ‹‰æ™®æ‹‰æ–¯/å¾¡ä¸‰å®¶é€²åŒ–", rate: 3}
                ],
                "ğŸ¬ ç³–æœæ‰­è›‹ (12 Candy)": [
                    {name: "ä¼Šå¸ƒ/çš®å¡ä¸˜", rate: 20}, {name: "å¾¡ä¸‰å®¶é€²åŒ–/å¡æ¯”/å‰åˆ©", rate: 10},
                    {name: "å¹¸ç¦è›‹", rate: 4}, {name: "æ‹‰æ™®æ‹‰æ–¯/å¿«é¾", rate: 3}
                ],
                "âœ¨ é»ƒé‡‘æ‰­è›‹ (3 Golden)": [
                    {name: "å¡æ¯”ç¸", rate: 30}, {name: "å‰åˆ©è›‹", rate: 40}, {name: "å¹¸ç¦è›‹", rate: 15},
                    {name: "æ‹‰æ™®æ‹‰æ–¯", rate: 7}, {name: "å¿«é¾", rate: 5}, {name: "è¶…å¤¢", rate: 3}
                ]
            };

            const myMoves = computed(() => user.value ? (MOVES_DB[user.value.pokemon_name] || MOVES_DB['default']) : []);
            const isMyTurn = computed(() => battleState.value.turn === 'player' && !battleState.value.winner);
            const petXpPercent = (u) => Math.min(100, (u.pet_exp / (u.next_pet_level_exp || 9999)) * 100);
            const playerXpPercent = computed(() => user.value ? Math.min(100, (user.value.exp / (user.value.next_level_exp || 9999)) * 100) : 0);
            
            const currentAtkMe = computed(() => user.value ? Math.floor(user.value.attack * (1 + battleState.value.buffs.me)) : 0);
            const currentAtkTarget = computed(() => battleState.value.target ? Math.floor(battleState.value.target.attack * (1 + battleState.value.buffs.target)) : 0);
            const hpPercent = (u) => (u.hp / u.max_hp) * 100;
            const getMoveClass = (move) => { if (move.type === 'buff') return 'move-buff'; if (move.type === 'heal') return 'move-heal'; return 'move-damage'; };
            const isUnlocked = (name) => user.value && user.value.unlocked_monsters && user.value.unlocked_monsters.includes(name);
            
            const collectionPercent = computed(() => {
                if (!user.value || !user.value.unlocked_monsters) return 0;
                const unlockedCount = user.value.unlocked_monsters.split(',').length;
                const totalCount = Object.keys(ALL_POKEMON).length;
                return Math.floor((unlockedCount / totalCount) * 100);
            });

            const addLog = (msg) => { logs.value.unshift(msg); if(logs.value.length > 50) logs.value.pop(); };

            if (!token) window.location.href = 'login.html';
            onMounted(async () => { await updateUserInfo(); await Promise.all([fetchMonsters(), fetchPlayers(), fetchQuests()]); connectWebSocket(); });
            watch(() => user.value?.pet_level, (newLv, oldLv) => { if(oldLv && newLv > oldLv) { showLevelUp.value = true; setTimeout(() => showLevelUp.value = false, 3000); } });
            
            watch(currentTab, async (n) => { 
                if(n=='wild') await fetchMonsters(); 
                if(n=='arena') await fetchPlayers(); 
                if(n=='quest') await fetchQuests(); 
                if(n=='social') await fetchSocialData(); // ğŸ”¥ è‡ªå‹•è®€å–å¥½å‹
            });

            const updateUserInfo = async () => { 
                try { 
                    const res = await fetch(`${API_URL}/auth/me`, { headers: { 'Authorization': `Bearer ${token}` } }); 
                    if(res.ok) { 
                        user.value = await res.json(); 
                        if(!selectedWildLevel.value) selectedWildLevel.value = user.value.level; 
                    } else if (res.status === 401) {
                        window.location.href = 'login.html';
                    }
                } catch(e) { console.error(e); } 
            };
            
            // ğŸ”¥ Social API ğŸ”¥
            const fetchSocialData = async () => {
                try {
                    const res1 = await fetch(`${API_URL}/social/list`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if(res1.ok) friends.value = await res1.json();
                    
                    const res2 = await fetch(`${API_URL}/social/requests`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if(res2.ok) friendRequests.value = await res2.json();
                } catch(e) { console.error(e); }
            };
            const addFriend = async (uid) => {
                const res = await fetch(`${API_URL}/social/add/${uid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } });
                const d = await res.json();
                alert(d.message);
            };
            const respondFriendRequest = async (reqId, accept) => {
                const action = accept ? 'accept' : 'reject';
                const res = await fetch(`${API_URL}/social/${action}/${reqId}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } });
                if(res.ok) { fetchSocialData(); alert(accept ? "å·²æ¥å—" : "å·²æ‹’çµ•"); }
            };

            const fetchMonsters = async () => { try { const lv = selectedWildLevel.value || 1; const res = await fetch(`${API_URL}/items/wild?level=${lv}`, { headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) monsters.value = await res.json(); } catch(e) { console.error(e); } };
            const fetchPlayers = async () => { try { const res = await fetch(`${API_URL}/auth/all`); if(res.ok) { const data = await res.json(); players.value = data.filter(u => u.id !== user.value?.id).sort((a,b) => b.is_online - a.is_online); } } catch(e) { console.error(e); } };
            const fetchQuests = async () => { 
                isQuestLoading.value = true;
                try { const res = await fetch(`${API_URL}/quests/`, { headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) quests.value = await res.json(); } 
                catch(e) { console.error(e); }
                finally { isQuestLoading.value = false; }
            };
            const acceptQuest = async (qid) => { const res = await fetch(`${API_URL}/quests/accept/${qid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { alert("ä»»å‹™å·²æ¥å—"); fetchQuests(); } else { const d = await res.json(); alert(d.detail); } };
            const abandonQuest = async (qid) => { if(confirm("ç¢ºå®šæ”¾æ£„æ­¤ä»»å‹™ï¼Ÿå°‡æœƒé‡æ–°æŠ½å–ä»»å‹™ã€‚")) { const res = await fetch(`${API_URL}/quests/abandon/${qid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { alert("ä»»å‹™å·²æ›´æ›"); fetchQuests(); } } };
            const claimQuest = async (qid) => { const res = await fetch(`${API_URL}/quests/claim/${qid}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); const d = await res.json(); if(res.ok) { alert(d.message); updateUserInfo(); fetchQuests(); } else alert(d.detail); };
            const confirmSwap = async (s) => { if(s) await fetch(`${API_URL.replace('/items', '')}/shop/swap/${gachaResult.value.prize.name}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); gachaResult.value.show = false; updateUserInfo(); };
            const swapFromDex = async (name) => { if (!isUnlocked(name)) return alert("æœªè§£é–"); if(confirm(`è®Šèº« ${name}?`)) await fetch(`${API_URL.replace('/items', '')}/shop/swap/${name}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); updateUserInfo(); };
            const buyHeal = async () => { const res = await fetch(`${API_URL.replace('/items', '')}/shop/heal`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); if(res.ok) { alert("è£œè¡€æˆåŠŸ"); updateUserInfo(); } else alert("é‡‘å¹£ä¸è¶³"); };
            const logout = () => { localStorage.clear(); window.location.href = 'login.html'; };
            const sendInvite = async (p) => { await fetch(`${API_URL.replace('/items', '')}/shop/duel/invite/${p.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); alert("å·²é‚€è«‹"); };
            const respondInvite = async (acc) => { inviteState.value.show = false; await fetch(`${API_URL.replace('/items', '')}/shop/duel/${acc?'accept':'reject'}/${inviteState.value.senderId}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); };
            const playGacha = async (type) => { try { isGachaAnimating.value = true; const res = await fetch(`${API_URL.replace('/items', '')}/shop/gacha/${type}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); const data = await res.json(); setTimeout(() => { isGachaAnimating.value = false; if(res.ok) { gachaResult.value = { show: true, prize: data.prize, isNew: data.is_new }; updateUserInfo(); } else alert(data.detail); }, 2500); } catch(e) { isGachaAnimating.value = false; } };

            const initBattle = (target, mode) => {
                clearInterval(timerInterval);
                if (!target || target.hp <= 0) return alert("ç›®æ¨™ç„¡æ•ˆ");
                battleState.value = { isActive: true, isActionProcessing: false, mode: mode, target: JSON.parse(JSON.stringify(target)), turn: 'player', timer: 10, defenseCount: 2, isDefending: false, winner: null, shakeMe: false, shakeTarget: false, buffs: { me: 0, target: 0 }, leechSeed: { onMe: false, onTarget: false }, turnCount: 1 };
                addLog(`âš”ï¸ é­é‡ ${target.name}ï¼`);
                if (mode === 'wild') startTimer();
            };

            const executePlayerMove = async (move) => {
                if (!isMyTurn.value || battleState.value.isActionProcessing) return;
                try {
                    battleState.value.isActionProcessing = true; clearInterval(timerInterval);
                    addLog(`ğŸ‘Š ä½¿ç”¨ ${move.name}ï¼`);
                    let atkBonus = 1 + (battleState.value.buffs.me);
                    let finalDmg = calculateRealDamage((user.value.attack || 0) * atkBonus, move.dmg);
                    const roll = Math.random();
                    if(move.chance === undefined || roll < move.chance) {
                        if(move.buff) { battleState.value.buffs.me += move.buff; showFloatingDamage('fighter-me', "ATK UP!", false, true); }
                        if(move.heal) { const h = Math.floor(user.value.max_hp * move.heal); user.value.hp = Math.min(user.value.max_hp, user.value.hp + h); showFloatingDamage('fighter-me', h, false, true); }
                    }
                    if(move.selfDmg) { const s = Math.floor(user.value.max_hp * move.selfDmg); user.value.hp = Math.max(0, user.value.hp - s); showFloatingDamage('fighter-me', s, false); }
                    if(move.dmg > 0) { battleState.value.shakeTarget = true; setTimeout(() => battleState.value.shakeTarget = false, 500); showFloatingDamage('fighter-target', finalDmg, false); battleState.value.target.hp = Math.max(0, battleState.value.target.hp - finalDmg); }
    
                    if (battleState.value.mode === 'wild') {
                        if (battleState.value.target.hp <= 0) {
                            let targetLv = 1; const match = battleState.value.target.name.match(/Lv\.(\d+)/); if(match) targetLv = parseInt(match[1]);
                            const res = await fetch(`${API_URL}/items/wild/attack`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ monster_name: battleState.value.target.name, is_dead: true, level: targetLv }) });
                            if(res.ok) { await fetchQuests(); await updateUserInfo(); }
                        }
                        if(!checkWinCondition()) { battleState.value.turn = 'enemy'; setTimeout(executeEnemyTurn, 1000); }
                    } else { await fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); battleState.value.turn = 'enemy'; }
                } catch(e) { console.error(e); } finally { battleState.value.isActionProcessing = false; }
            };

            const executeDefense = () => { if (battleState.value.defenseCount <= 0 || battleState.value.isActionProcessing) return; clearInterval(timerInterval); battleState.value.defenseCount--; battleState.value.isDefending = true; addLog(`ğŸ›¡ï¸ é˜²ç¦¦ï¼`); battleState.value.turn = 'enemy'; if(battleState.value.mode === 'wild') setTimeout(executeEnemyTurn, 1500); else fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); };
            
            const executeEnemyTurn = () => {
                if (battleState.value.winner) return;
                let enemyName = battleState.value.target.name.split('(')[0].trim().replace('ğŸ‘‘','').trim();
                const moves = WILD_MOVES[enemyName] || MOVES_DB['default'];
                const move = moves[Math.floor(Math.random() * moves.length)];
                addLog(`âš ï¸ å°æ‰‹ä½¿ç”¨ ${move.name}ï¼`);
                let enemyAtk = battleState.value.target.attack || 50; 
                let dmg = calculateRealDamage(enemyAtk * (1 + battleState.value.buffs.target), move.dmg);
                if (battleState.value.isDefending) { const reflect = Math.floor(dmg * 0.3); dmg = 0; battleState.value.target.hp = Math.max(0, battleState.value.target.hp - reflect); showFloatingDamage('fighter-target', reflect, false); addLog(`ğŸ›¡ï¸ åå½ˆ ${reflect} å‚·ï¼`); battleState.value.isDefending = false; }
                if(dmg > 0) { battleState.value.shakeMe = true; setTimeout(() => battleState.value.shakeMe = false, 500); showFloatingDamage('fighter-me', dmg, true); user.value.hp = Math.max(0, user.value.hp - dmg); }
                if (battleState.value.mode === 'wild' && battleState.value.target.hp <= 0) { let targetLv = 1; const match = battleState.value.target.name.match(/Lv\.(\d+)/); if(match) targetLv = parseInt(match[1]); fetch(`${API_URL}/items/wild/attack`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ monster_name: battleState.value.target.name, is_dead: true, level: targetLv }) }).then(()=>{fetchQuests();updateUserInfo();}); }
                if(!checkWinCondition()) { battleState.value.turn = 'player'; startTimer(); }
            };

            const endBattle = async () => { clearInterval(timerInterval); if (battleState.value.mode === 'pvp') await fetch(`${API_URL.replace('/items', '')}/shop/duel/end/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); battleState.value.isActive = false; battleState.value.winner = null; updateUserInfo(); fetchQuests(); };
            const startTimer = () => { clearInterval(timerInterval); battleState.value.timer = 10; timerInterval = setInterval(() => { if (!battleState.value.isActive) { clearInterval(timerInterval); return; } battleState.value.timer--; if (battleState.value.timer <= 0) { clearInterval(timerInterval); if(battleState.value.mode === 'wild') { battleState.value.turn = 'enemy'; setTimeout(executeEnemyTurn, 1000); } else { fetch(`${API_URL.replace('/items', '')}/shop/pvp/${battleState.value.target.id}`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } }); battleState.value.turn = 'enemy'; } } }, 1000); };
            const checkWinCondition = () => { if (battleState.value.target.hp <= 0) { battleState.value.winner = 'player'; return true; } if (user.value.hp <= 0) { battleState.value.winner = 'enemy'; return true; } return false; };
            const connectWebSocket = () => { socket = new WebSocket(`${WS_URL}?token=${token}`); socket.onopen = () => setInterval(() => socket.readyState===1 && socket.send("ping"), 30000); socket.onmessage = (e) => { const msg = e.data; const parts = msg.split("|"); if (msg.startsWith("ğŸ“¢")) addLog(msg); if (msg.startsWith("EVENT:DUEL_INVITE") && parseInt(parts[3]) === user.value.id) inviteState.value = { show: true, senderId: parts[1], senderName: parts[2] }; if (msg.startsWith("EVENT:DUEL_START")) { const p1=parseInt(parts[1]), p2=parseInt(parts[3]), first=parseInt(parts[5]); if(user.value.id===p1 || user.value.id===p2) { inviteState.value.show = false; const oppId = user.value.id===p1 ? p2 : p1; fetchPlayers().then(() => { const opp = players.value.find(p=>p.id===oppId); if(opp) { initBattle(opp, 'pvp'); battleState.value.turn = user.value.id===first?'player':'enemy'; if(battleState.value.turn==='player') startTimer(); } }); } } if (msg.startsWith("EVENT:PVP_MOVE")) { const targetId = parseInt(parts[2]); if (battleState.value.isActive && user.value.id === targetId) { fetchPlayers().then(() => { const opp = players.value.find(p => p.id === parseInt(parts[1])); if(opp) battleState.value.target.hp = opp.hp; const me = players.value.find(p => p.id === user.value.id); if(me) user.value.hp = me.hp; if(!checkWinCondition()) { battleState.value.turn = 'player'; startTimer(); } }); } } fetchMonsters(); fetchPlayers(); updateUserInfo(); fetchQuests(); }; };
            watch(currentTab, async (n) => { if(n=='wild') await fetchMonsters(); if(n=='arena') await fetchPlayers(); if(n=='quest') await fetchQuests(); if(n=='social') await fetchSocialData(); });

            return { user, monsters, players, quests, friends, friendRequests, inventory, currentTab, battleState, myMoves, isMyTurn, inviteState, gachaResult, ALL_POKEMON, hpPercent, petXpPercent, playerXpPercent, logout, initBattle, executePlayerMove, executeDefense, endBattle, playGacha, buyHeal, sendInvite, respondInvite, confirmSwap, swapFromDex, isUnlocked, isGachaAnimating, acceptQuest, claimQuest, abandonQuest, addFriend, respondFriendRequest, selectedWildLevel, fetchMonsters, currentAtkMe, currentAtkTarget, calculateDisplayDmg, showLevelUp, getMoveClass, logs, isQuestLoading, rateState, gachaRates, collectionPercent };
        }
    }).mount('#app');
</script>

</body>
</html>